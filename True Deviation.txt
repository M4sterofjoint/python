//:)
//██╗███╗░░██╗███╗░░██╗███████╗██████╗░
//██║████╗░██║████╗░██║██╔════╝██╔══██╗👁‍🗨VIPER👁‍🗨
//██║██╔██╗██║██╔██╗██║█████╗░░██████╔╝
//██║██║╚████║██║╚████║██╔══╝░░██╔══██╗
//██║██║░╚███║██║░╚███║███████╗██║░░██║
//╚═╝╚═╝░░╚══╝╚═╝░░╚══╝╚══════╝╚═╝░░╚═╝

//░█████╗░██╗██████╗░░█████╗░██╗░░░░░███████╗
//██╔══██╗██║██╔══██╗██╔══██╗██║░░░░░██╔════╝
//██║░░╚═╝██║██████╔╝██║░░╚═╝██║░░░░░█████╗░░
//██║░░██╗██║██╔══██╗██║░░██╗██║░░░░░██╔══╝░░
//╚█████╔╝██║██║░░██║╚█████╔╝███████╗███████╗
//░╚════╝░╚═╝╚═╝░░╚═╝░╚════╝░╚══════╝╚══════╝

//██╗░░░██╗██╗██████╗░███████╗██████╗░
//██║░░░██║██║██╔══██╗██╔════╝██╔══██╗
//╚██╗░██╔╝██║██████╔╝█████╗░░██████╔╝
//░╚████╔╝░██║██╔═══╝░██╔══╝░░██╔══██╗
//░░╚██╔╝░░██║██║░░░░░███████╗██║░░██║
//░░░╚═╝░░░╚═╝╚═╝░░░░░╚══════╝╚═╝░░╚═╝
//
//
//@version=5
indicator(" TRUE Deviation BY👁‍🗨VIPER👁‍🗨SYSTEMS", shorttitle="👁‍🗨VIPER👁‍🗨SYSTEMS👁‍🗨 TRUE DEVIATIONS", overlay=true)
length1 = input.int(128, title="length1", minval = 1, maxval = 5000)
src = input.source(close, title="Source")
std_dev_chn_group = "DEVIATIONS SETTING"
upprinp = input.bool(true, title="Upper Deviation +1", inline = "Upper Deviation", group = std_dev_chn_group)
upprmltinp = input.float(1.27, title="", inline = "Upper Deviation", group = std_dev_chn_group)
lwrinp = input.bool(true, title="Lower Deviation -1", inline = "Lower Deviation", group = std_dev_chn_group)
lwrMultInput = input.float(1.27, title="", inline = "Lower Deviation", group = std_dev_chn_group)
upprinp2 = input.bool(true, title="Upper Deviation +2", inline = "Upper Deviation", group = std_dev_chn_group)
upprmltinp2 = input.float(3.68, title="", inline = "Upper Deviation", group = std_dev_chn_group)
lwrinp2 = input.bool(true, title="Lower Deviation 2-", inline = "Lower Deviation", group = std_dev_chn_group)
lwrmultinp = input.float(3.68, title="", inline = "Lower Deviation", group = std_dev_chn_group)
col_settings_group = "Color Settings"
coluppr = input.color(color.new(#bb02ff, 81), "", inline = col_settings_group, group = col_settings_group)
collwr = input.color(color.new(#cceb00, 72), "", inline = col_settings_group, group = col_settings_group)
coluppr2 = input.color(color.new(#51da55, 57), "", inline = col_settings_group, group = col_settings_group)
collwr2 = input.color(color.new(#0c9611, 62), "", inline = col_settings_group, group = col_settings_group)
visual_settings_group = "Visual Settings"
prinp = input.bool(false, "Show Pearson's R", group = visual_settings_group)
exl = input.bool(false, "Extend Lines Left", group = visual_settings_group)
exr = input.bool(false, "Extend Lines Right", group = visual_settings_group)
exs = switch
    exl and exr => extend.both
    exl => extend.left
    exr => extend.right
    => extend.none

slpclc(source, length1) =>
    max_bars_back(source, 5000)
    if not barstate.islast or length1 <= 1
        [float(na), float(na), float(na)]
    else
        sumX = 0.0
        sumY = 0.0
        sumXSqr = 0.0
        sumXY = 0.0
        for i = 0 to length1 - 1 by 1
            val = source[i]
            per = i + 1.0
            sumX += per
            sumY += val
            sumXSqr += per * per
            sumXY += val * per
        slope = (length1 * sumXY - sumX * sumY) / (length1 * sumXSqr - sumX * sumX)
        average = sumY / length1
        intercept = average - slope * sumX / length1 + slope
        [slope, average, intercept]
        
[s, a, i] = slpclc(src, length1)
st_price = i + s * (length1 - 1)
end_price = i
var line base_line = na
if na(base_line) and not na(st_price)
    base_line := line.new(bar_index - length1 + 1, st_price, bar_index, end_price, width=1, extend=exs, style=line.style_dashed, color=color.new(collwr, 0))
else
    line.set_xy1(base_line, bar_index - length1 + 1, st_price)
    line.set_xy2(base_line, bar_index, end_price)
    na
    
devcalc(source, length1, slope, average, intercept) =>
    upDev = 0.0
    dnDev = 0.0
    stdDevAcc = 0.0
    dsxx = 0.0
    dsyy = 0.0
    dsxy = 0.0
    periods = length1 - 1
    daY = intercept + slope * periods / 2
    val = intercept
    for j = 0 to periods by 1
        price = high[j] - val
        if price > upDev
            upDev := price
        price := val - low[j]
        if price > dnDev
            dnDev := price
        price := source[j]
        dxt = price - average
        dyt = val - daY
        price -= val
        stdDevAcc += price * price
        dsxx += dxt * dxt
        dsyy += dyt * dyt
        dsxy += dxt * dyt
        val += slope
    stdDev = math.sqrt(stdDevAcc / (periods == 0 ? 1 : periods))
    pearsonR = dsxx == 0 or dsyy == 0 ? 0 : dsxy / math.sqrt(dsxx * dsyy)
    [stdDev, pearsonR, upDev, dnDev]

devcalc2(source, length1, slope, average, intercept) =>
    upDev2 = 0.0
    dnDev2 = 0.0
    stdDevAcc = 0.0
    dsxx = 0.0
    dsyy = 0.0
    dsxy = 0.0
    periods = length1 - 1
    daY = intercept + slope * periods / 2
    val = intercept
    for j = 0 to periods by 1
        price = high[j] - val
        if price > upDev2
            upDev2 := price
        price := val - low[j]
        if price > dnDev2
            dnDev2 := price
        price := source[j]
        dxt = price - average
        dyt = val - daY
        price -= val
        stdDevAcc += price * price
        dsxx += dxt * dxt
        dsyy += dyt * dyt
        dsxy += dxt * dyt
        val += slope
    stdDev2 = math.sqrt(stdDevAcc / (periods == 0 ? 1 : periods))
    pearsonR2 = dsxx == 0 or dsyy == 0 ? 0 : dsxy / math.sqrt(dsxx * dsyy)
    [stdDev2, pearsonR2, upDev2, dnDev2]
    
[stdDev, pearsonR, upDev, dnDev] = devcalc(src, length1, s, a, i)
upprst_price = st_price + (upprinp ? upprmltinp * stdDev : upDev)
upprend_price = end_price + (upprinp ? upprmltinp * stdDev : upDev)
var line uppr = na
lwrst_price = st_price + (lwrinp ? -lwrMultInput * stdDev : -dnDev)
lwrend_price = end_price + (lwrinp ? -lwrMultInput * stdDev : -dnDev)
var line lwr = na
if na(uppr) and not na(upprst_price)
    uppr := line.new(bar_index - length1 + 1, upprst_price, bar_index, upprend_price, width=1, style=line.style_dashed, extend=exs, color=color.new(coluppr, 0))
else
    line.set_xy1(uppr, bar_index - length1 + 1, upprst_price)
    line.set_xy2(uppr, bar_index, upprend_price)
    na
if na(lwr) and not na(lwrst_price)
    lwr := line.new(bar_index - length1 + 1, lwrst_price, bar_index, lwrend_price, width=1, style=line.style_dashed, extend=exs, color=color.new(collwr, 0))
else
    line.set_xy1(lwr, bar_index - length1 + 1, lwrst_price)
    line.set_xy2(lwr, bar_index, lwrend_price)
    na
linefill.new(uppr, base_line, color = coluppr)
linefill.new(base_line, lwr, color = collwr)

[stdDev2, pearsonR2, upDev2, dnDev2] = devcalc2(src, length1, s, a, i)
upprst_price2 = st_price + (upprinp2 ? upprmltinp2 * stdDev2 : upDev2)
upprend_price2 = end_price + (upprinp2 ? upprmltinp2 * stdDev2 : upDev2)
var line uppr2 = na
lwrst_price2 = st_price + (lwrinp2 ? -lwrmultinp * stdDev2 : -dnDev2)
lwrend_price2 = end_price + (lwrinp2 ? -lwrmultinp * stdDev2 : -dnDev2)
var line lwr2 = na
if na(uppr2) and not na(upprst_price2)
    uppr2 := line.new(bar_index - length1 + 2, upprst_price2, bar_index, upprend_price2, width=1, style=line.style_dashed, extend=exs, color=color.new(coluppr2, 0))
else
    line.set_xy1(uppr2, bar_index - length1 + 2, upprst_price2)
    line.set_xy2(uppr2, bar_index, upprend_price2)
    na
if na(lwr2) and not na(lwrst_price2)
    lwr2 := line.new(bar_index - length1 + 2, lwrst_price2, bar_index, lwrend_price2, width=1, style=line.style_dashed, extend=exs, color=color.new(collwr2, 0))
else
    line.set_xy1(lwr2, bar_index - length1 + 2, lwrst_price2)
    line.set_xy2(lwr2, bar_index, lwrend_price2)
    na
var label r = na
label.delete(r[1])
if prinp and not na(pearsonR)
    r := label.new(bar_index - length1 + 1, lwrst_price, str.tostring(pearsonR, "#.################"), color = color.new(#c2c2c2, 77), textcolor=color.new(coluppr, 0), size=size.normal, style=label.style_label_up)
    
uppr_break = ta.crossover(close, upprend_price)
lwr_break = ta.crossunder(close, lwrend_price)

uppr2_break = ta.crossover(close, upprend_price2)
lwr2_break = ta.crossunder(close, lwrend_price2)

alertcondition(uppr_break, title = "Upper Line Break Alert", message = "Upper Line has been break!")
alertcondition(lwr_break, title = "Lower Line Break Alert", message = "Lower Line has been break!")

alertcondition(uppr2_break, title = "Upper 2 Line Break Alert", message = "Upper 2 Line has been break!")
alertcondition(lwr2_break, title = "Lower 2 Line Break Alert", message = "Lower 2 Line has been break!")
//
//👁‍🗨VIPER👁‍🗨SYSTEMS👁‍🗨 TRUE DEVIATIONS
//text inputs
//
//🐢 🐢🍲🍲
//text inputs
title = input.string('👁‍🗨VIPER👁‍🗨SYSTEMS👁‍🗨|TRUE DEVIATIONS|', 'Tittle', group='text')
subtitle = input.string('PATIENCE |  DISCIPLINE  | CONSISTENCY|👁‍🗨 IN MATH WE TRUST👁‍🗨', 'Subtitle', group='text')
//symbol info
symInfoCheck = input.bool(title='Show Symbol Info', defval=true, group='watermark position')
symInfo = syminfo.ticker + ' | ' + timeframe.period + (timeframe.isminutes ? 'M' : na)
date = str.tostring(dayofmonth(time_close)) + '/' + str.tostring(month(time_close)) + '/' + str.tostring(year(time_close))
//text positioning
textVPosition = input.string('top', 'Vertical Position', options=['top', 'middle', 'bottom'], group='watermark position')
textHPosition = input.string('center', 'Horizontal Position', options=['left', 'center', 'right'], group='watermark position')
//symbol info positioning
symVPosition = input.string('bottom', 'Vertical Position', options=['top', 'middle', 'bottom'], group='symbol position')
symHPosition = input.string('center', 'Horizontal Position', options=['left', 'center', 'right'], group='symbol position')
//cell size
width = input.int(35, 'Width', minval=0, maxval=100, tooltip='The width of the cell as a % of the indicator\'s visual space. Optional. By default, auto-adjusts the width based on the text inside the cell. Value 0 has the same effect.', group='cell size')
height = input.int(0, 'Height', minval=0, maxval=100, tooltip='The height of the cell as a % of the indicator\'s visual space. Optional. By default, auto-adjusts the height based on the text inside of the cell. Value 0 has the same effect.', group='cell size')
//title settings
c_title = input.color(color.new(color.black, 0), 'Title Color', group='title settings')
s_title = input.string('large', 'Title Size', options=['tiny', 'small', 'normal', 'large', 'huge', 'auto'], group='title settings')
a_title = input.string('center', 'Title Alignment', options=['center', 'left', 'right'], group='title settings')
//subtitle settings
c_subtitle = input.color(color.new(color.black, 30), 'Subitle Color', group='subtitle settings')
s_subtitle = input.string('normal', 'Subtitle Size', options=['tiny', 'small', 'normal', 'large', 'huge', 'auto'], group='subtitle settings')
a_subtitle = input.string('center', 'Subtitle Alignment', options=['center', 'left', 'right'], group='subtitle settings')

//symbol settings
c_symInfo = input.color(color.new(color.black, 30), 'Subitle Color', group='symbol settings')
s_symInfo = input.string('normal', 'Subtitle Size', options=['tiny', 'small', 'normal', 'large', 'huge', 'auto'], group='symbol settings')
a_symInfo = input.string('center', 'Subtitle Alignment', options=['center', 'left', 'right'], group='symbol settings')
c_bg = input.color(color.new(color.blue, 100), 'Background', group='background')


//text watermark creation
textWatermark = table.new(textVPosition + '_' + textHPosition, 1, 3)
table.cell(textWatermark, 0, 0, title, width, height, c_title, a_title, text_size=s_title, bgcolor=c_bg)
table.cell(textWatermark, 0, 1, subtitle, width, height, c_subtitle, a_subtitle, text_size=s_subtitle, bgcolor=c_bg)
//symbol info watermark creation
symWatermark = table.new(symVPosition + '_' + symHPosition, 5, 5)
if symInfoCheck == true
    table.cell(symWatermark, 0, 1, symInfo, width, height, c_symInfo, a_symInfo, text_size=s_symInfo, bgcolor=c_bg)
    table.cell(symWatermark, 0, 0, date, width, height, c_symInfo, a_symInfo, text_size=s_symInfo, bgcolor=c_bg)
//
//title = input.string('👁‍🗨VIPER👁‍🗨SYSTEMS👁‍🗨 TRUE DEVIATIONS', 'Tittle', group='text')



source = close

// MACD Options
allowelder = input.string(defval='On', options=['On', 'Off'], title='Elder Impulse')
macd_length_fast = input.int(defval=12, minval=1, title='MACD Fast Length (Elder Impulse)')
macd_length_slow = input.int(defval=26, minval=1, title='MACD Slow Length (Elder Impulse)')
macd_length_signal = input.int(defval=9, minval=1, title='MACD Signal Length (Elder Impulse)')
// Calculate MACD
macd_ma_fast = ta.ema(source, macd_length_fast)
macd_ma_slow = ta.ema(source, macd_length_slow)
macd = macd_ma_fast - macd_ma_slow
macd_signal = ta.ema(macd, macd_length_signal)
macd_histogram = macd - macd_signal

// EMA Option
ema_length = input.int(defval=13, minval=1, title='EMA 👁‍🗨 (Elder Impulse)')
// Calculate EMA
ema = ta.ema(source, ema_length)

// Calculate Elder Impulse
elder_bulls = ema[0] > ema[1] and macd_histogram[0] > macd_histogram[1]
elder_bears = ema[0] < ema[1] and macd_histogram[0] < macd_histogram[1]
elder_color = elder_bulls ? color.green : elder_bears ? color.red : color.blue
normal_color = close > open ? color.green : color.red
bar_color = allowelder == 'On' ? elder_color : normal_color

len1 = input.int(20, minval=1, title='Triple MA1')
len2 = input.int(50, minval=1, title='Triple MA2')
len3 = input.int(200, minval=1, title='Triple MA3')
src1 = input(close, title='Triple MA Source')
type = input.string(defval='SMA', options=['SMA', 'EMA'], title='Triple MA Type')
sma_1 = ta.sma(src1, len1)
ema_1 = ta.ema(src1, len1)
out1 = type == 'SMA' ? sma_1 : ema_1
sma_2 = ta.sma(src1, len2)
ema_2 = ta.ema(src, len2)
out2 = type == 'SMA' ? sma_2 : ema_2
sma_3 = ta.sma(src1, len3)
ema_3 = ta.ema(src, len3)
out3 = type == 'SMA' ? sma_3 : ema_3
//plot(out1, title='MA1', color=color.new(color.blue, 0))
//plot(out2, title='MA2', color=color.new(color.red, 0))
//plot(out3, title='MA3', color=color.new(color.green, 0))

barcolor(bar_color)
//
// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ICT-VIPER
// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © ICT-VIPER
//@version=5
//
//██╗███╗░░██╗███╗░░██╗███████╗██████╗░
//██║████╗░██║████╗░██║██╔════╝██╔══██╗
//██║██╔██╗██║██╔██╗██║█████╗░░██████╔╝
//██║██║╚████║██║╚████║██╔══╝░░██╔══██╗
//██║██║░╚███║██║░╚███║███████╗██║░░██║
//╚═╝╚═╝░░╚══╝╚═╝░░╚══╝╚══════╝╚═╝░░╚═╝

//░█████╗░██╗██████╗░░█████╗░██╗░░░░░███████╗
//██╔══██╗██║██╔══██╗██╔══██╗██║░░░░░██╔════╝
//██║░░╚═╝██║██████╔╝██║░░╚═╝██║░░░░░█████╗░░
//██║░░██╗██║██╔══██╗██║░░██╗██║░░░░░██╔══╝░░
//╚█████╔╝██║██║░░██║╚█████╔╝███████╗███████╗
//░╚════╝░╚═╝╚═╝░░╚═╝░╚════╝░╚══════╝╚══════╝

//██╗░░░██╗██╗██████╗░███████╗██████╗░
//██║░░░██║██║██╔══██╗██╔════╝██╔══██╗
//╚██╗░██╔╝██║██████╔╝█████╗░░██████╔╝
//░╚████╔╝░██║██╔═══╝░██╔══╝░░██╔══██╗
//░░╚██╔╝░░██║██║░░░░░███████╗██║░░██║
//░░░╚═╝░░░╚═╝╚═╝░░░░░╚══════╝╚═╝░░╚═╝
//
//
//indicator("ADVANCED SWING THEORY BY [VIPER]"
//  , overlay = true
//  , max_lines_count = 500
//  , max_labels_count = 500
//  , max_boxes_count = 500)
 
// Set the minimal candle size in pips
//Settings
//-----------------------------------------------------------------------------{
//Settings
//-----------------------------------------------------------------------------{
length = input(14, '👁‍🗨')

area = input.string('Wick Extremity', 'Swing Area', options = ['Wick Extremity', 'Full Range'])

intraPrecision = input(false, 'Intrabar Precision', inline = 'intrabar')
intrabarTf = input.timeframe('1', ''              , inline = 'intrabar')

filterOptions = input.string('Count', 'Filter Areas By', options = ['Count', 'Volume'], inline = 'filter')
filterValue   = input.float(0, ''                                            , inline = 'filter')

//Style
showTop      = input(true, 'Swing High'              , inline = 'top', group = 'Style')
topCss       = input(color.rgb(255, 82, 82, 52), ''                   , inline = 'top', group = 'Style')
topAreaCss   = input(color.new(#ff5252, 78), 'Area', inline = 'top', group = 'Style')

showBtm      = input(true, 'Swing Low'                , inline = 'btm', group = 'Style')
btmCss       = input(color.teal, ''                   , inline = 'btm', group = 'Style')
btmAreaCss   = input(color.new(color.teal, 50), 'Area', inline = 'btm', group = 'Style')

labelSize = input.string('Tiny', 'Labels Size', options = ['Tiny', 'Small', 'Normal'], group = 'Style')

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{
n = bar_index

get_data()=> [high, low, volume]

[h, l, v] = request.security_lower_tf(syminfo.tickerid, intrabarTf, get_data())

get_counts(condition, top, btm)=>
    var count = 0
    var vol = 0.

    if condition
        count := 0
        vol := 0.
    else
        if intraPrecision
            if n > length
                if array.size(v[length]) > 0
                    for [index, element] in v[length]
                        vol += array.get(l[length], index) < top and array.get(h[length], index) > btm ? element : 0
        else
            vol += low[length] < top and high[length] > btm ? volume[length] : 0
        
        count += low[length] < top and high[length] > btm ? 1 : 0

    [count, vol]

set_label(count, vol, x, y, css, lbl_style)=>
    var label lbl = na
    var label_size = switch labelSize
        'Tiny' => size.tiny
        'Small' => size.small
        'Normal' => size.normal

    target = switch filterOptions
        'Count'  => count
        'Volume' => vol

    if ta.crossover(target, filterValue)
        lbl := label.new(x, y, str.tostring(vol, format.volume)
          , style = lbl_style
          , size = label_size
          , color = #00000000
          , textcolor = css)

    if target > filterValue
        label.set_text(lbl, str.tostring(vol, format.volume))

set_level(condition, crossed, value, count, vol, css)=>
    var line lvl = na

    target = switch filterOptions
        'Count'  => count
        'Volume' => vol

    if condition
        if target[1.5] < filterValue[1.5]
            line.delete(lvl[1.5])
        else if not crossed[1.5]
            line.set_x2(lvl, n - length)

        lvl := line.new(n - length, value, n, value
          , color = na)

    if not crossed[1]
        line.set_x2(lvl, n+3)
    
    if crossed and not crossed[1]
        line.set_x2(lvl, n)
        line.set_style(lvl, line.style_dashed)

    if target > filterValue
        line.set_color(lvl, css)

set_zone(condition, x, top, btm, count, vol, css)=>
    var box bx = na

    target = switch filterOptions
        'Count'  => count
        'Volume' => vol

    if ta.crossover(target, filterValue)
        bx := box.new(x, top, x + count, btm
          , border_color = na
          , bgcolor = css)
    
    if target > filterValue
        box.set_right(bx, x + count)

//-----------------------------------------------------------------------------}
//Global variables
//-----------------------------------------------------------------------------{
//Pivot high
var float ph_top = na
var float ph_btm = na
var bool  ph_crossed = na
var       ph_x1 = 0
var box   ph_bx = box.new(na,na,na,na
  , bgcolor = color.new(topAreaCss, 80)
  , border_color = na)

//Pivot low
var float pl_top = na
var float pl_btm = na
var bool  pl_crossed = na
var       pl_x1 = 0
var box   pl_bx = box.new(na,na,na,na
  , bgcolor = color.new(btmAreaCss, 80)
  , border_color = na)

//-----------------------------------------------------------------------------}
//Display pivot high levels/blocks
//-----------------------------------------------------------------------------{
ph = ta.pivothigh(length, length)

//Get ph counts
[ph_count, ph_vol] = get_counts(ph, ph_top, ph_btm)

//Set ph area and level
if ph and showTop
    ph_top := high[length]
    ph_btm := switch area 
        'Wick Extremity' => math.max(close[length], open[length])
        'Full Range' => low[length]
    
    ph_x1 := n - length
    ph_crossed := false

    box.set_lefttop(ph_bx, ph_x1, ph_top)
    box.set_rightbottom(ph_bx, ph_x1, ph_btm)
else
    ph_crossed := close > ph_top ? true : ph_crossed
    
    if ph_crossed
        box.set_right(ph_bx, ph_x1)
    else
        box.set_right(ph_bx, n+3)

if showTop
    //Set ph zone
    set_zone(ph, ph_x1, ph_top, ph_btm, ph_count, ph_vol, topAreaCss)

    //Set ph level
    set_level(ph, ph_crossed, ph_top, ph_count, ph_vol, topCss)

    //Set ph label
    set_label(ph_count, ph_vol, ph_x1, ph_top, topCss, label.style_label_down)

//-----------------------------------------------------------------------------}
//Display pivot low levels/blocks
//-----------------------------------------------------------------------------{
pl = ta.pivotlow(length, length)

//Get pl counts
[pl_count, pl_vol] = get_counts(pl, pl_top, pl_btm)

//Set pl area and level
if pl and showBtm
    pl_top := switch area 
        'Wick Extremity' => math.min(close[length], open[length])
        'Full Range' => high[length] 
    pl_btm := low[length]
    
    pl_x1 := n - length
    pl_crossed := false
    
    box.set_lefttop(pl_bx, pl_x1, pl_top)
    box.set_rightbottom(pl_bx, pl_x1, pl_btm)
else
    pl_crossed := close < pl_btm ? true : pl_crossed

    if pl_crossed
        box.set_right(pl_bx, pl_x1)
    else
        box.set_right(pl_bx, n+3)

if showBtm
    //Set pl zone
    set_zone(pl, pl_x1, pl_top, pl_btm, pl_count, pl_vol, btmAreaCss)
    
    //Set pl level
    set_level(pl, pl_crossed, pl_btm, pl_count, pl_vol, btmCss)

    //Set pl labels
    set_label(pl_count, pl_vol, pl_x1, pl_btm, btmCss, label.style_label_up)

//-----------------------------------------------------------------------------}
//Settings
//-----------------------------------------------------------------------------{

liqLength = input.int(3 , 'Liquidity Levels', minval = 1/2)

showMajor = input(true, 'Show Major RIEMANN pattern')
showMinor = input(true, 'Show Minor RIEMANN Pattern')

//Style
bullCss = input.color(color.rgb(189, 0, 218), 'Bullish Pattern', inline = 'bull', group = 'Pattern Style')
showBullBox = input(true, 'Area', inline = 'bull', group = 'Pattern Style')
showBullLvl = input(true, 'Line', inline = 'bull', group = 'Pattern Style')

bearCss = input.color(color.rgb(255, 140, 0, 20), 'Bearish Pattern', inline = 'bear', group = 'Pattern Style')
showBearBox = input(true, 'Area', inline = 'bear', group = 'Pattern Style')
showBearLvl = input(true, 'Line', inline = 'bear', group = 'Pattern Style')

//Liquidity Style
showLiq = input(true, 'Show Liquidity Levels', group = 'Liquidity')
bullLiqCss = input.color(color.teal, 'Upper Liquidity', group = 'Liquidity')
bearLiqCss = input.color(color.rgb(255, 0, 0), 'Lower Liquidity', group = 'Liquidity')

//-----------------------------------------------------------------------------}
//UDT
//-----------------------------------------------------------------------------{
type mp
    box area
    line avg
    bool breakup
    bool breakdn

//-----------------------------------------------------------------------------}
//Detect contraction
//-----------------------------------------------------------------------------{
var phy = 0., var phx = 0, var pht = 0.
var ply = 0., var plx = 0, var plt = 0.

var float top = na
var float btm = na


if ph
    pht := math.sign(ph - phy)
    phy := ph

    if pht == -1 and plt == 1
        top := ph
        btm := ply
        phx := n-length

if pl
    plt := math.sign(pl - ply)
    ply := pl

    if pht  == -1 and plt == 1
        top := phy
        btm := pl
        plx := n-length

//-----------------------------------------------------------------------------}
//Set pattern
//-----------------------------------------------------------------------------{
var mp master = mp.new()

//Detect master pattern
isbull = open[length] > top and top < btm
isbear = close[length] < btm and top > btm

if isbull or isbear
    css = isbull ? bullCss : bearCss

    master.avg.set_x2(n-length)

    val = math.avg(top, btm)

    //Create new master pattern object
    master := mp.new(
      (isbull and showBullBox) or (isbear and showBearBox) ? box.new(math.max(phx, plx), top, n-length, btm, na, bgcolor = showMinor ? color.new(css, 50) : na) : na
      , (isbull and showBullLvl) or (isbear and showBearLvl) ? line.new(n-length, val, n, val, color = showMinor ? css : na) : na
      , isbull
      , isbear)

    top := na
    btm := na

//Determine if pattern switch to major
if master.breakup
    if low < master.area.get_bottom()
        if not showMajor
            master.area.delete()
            master.avg.delete()
        else
            master.area.set_border_color(bullCss)
            if not showMinor
                master.area.set_bgcolor(color.new(bullCss, 50))
                master.avg.set_color(bullCss)
else if master.breakdn
    if high > master.area.get_top()
        if not showMajor
            master.area.delete()
            master.avg.delete()
        else
            master.area.set_border_color(bearCss)
            if not showMinor
                master.area.set_bgcolor(color.new(bearCss, 50))
                master.avg.set_color(bearCss)

//Set friction level x2 coordinate to current bar
if not na(master.avg)
    master.avg.set_x2(n)

//-----------------------------------------------------------------------------}
//Liquidity levels
//-----------------------------------------------------------------------------{
var line liqup = na, var liqup_reach = false
var line liqdn = na, var liqdn_reach = false

liqph = ta.pivothigh(liqLength, liqLength)
liqpl = ta.pivotlow(liqLength, liqLength)

//Set upper liquidity
if liqph and showLiq
    if not liqup_reach
        liqup.set_x2(n-liqLength)

    liqup := line.new(n-liqLength, liqph, n, liqph, color = bullLiqCss, style = line.style_dotted)
    liqup_reach := false
else if not liqup_reach and showLiq
    liqup.set_x2(n)

    if high > liqup.get_y1()
        liqup_reach := true

//Set lower liquidity
if liqpl and showLiq
    if not liqdn_reach
        liqdn.set_x2(n-liqLength)

    liqdn := line.new(n-liqLength, liqpl, n, liqpl, color = bearLiqCss, style = line.style_dotted)
    liqdn_reach := false
else if not liqdn_reach and showLiq
    liqdn.set_x2(n)

    if low < liqdn.get_y1()
        liqdn_reach := true

//-----------------------------------------------------------------------------}

//#region[Global]
colorLBL = input.color(color.black, title = "Label Color")
//#endregion



